use core::ops::Mul;
use core::convert::TryInto;
use sha3::{Sha3_512, Digest};

use rabe_bn::{Fr, Gt};

/// Hashes a bit string to the group generated by a given generator (additive notation)
pub fn hash_to_curve<G>(inp: &[u8], generator: G) -> G::Output
where G: Mul<Fr>
{
    let hashed = Sha3_512::digest(inp);
    let scalar = Fr::interpret(hashed.as_slice().try_into().unwrap());
    generator * scalar
}

/// Hashes a bit string to Gt (Gt has multiplicative notation, can't use generic hash_to_curve implementation)
pub fn hash_to_gt(inp: &[u8], generator: Gt) -> Gt {
    let hashed = Sha3_512::digest(inp);
    let scalar = Fr::interpret(hashed.as_slice().try_into().unwrap());
    generator.pow(scalar)
}

#[cfg(test)]
mod test {
    use super::*;

    use rabe_bn::{G1, G2, Gt};
    use rand::Rng;

    #[test]
    fn test_hash_to_g1() {
        let mut rng = rand::thread_rng();
        let gen1: G1 = rng.gen();
        let att1 = "attribute 1";
        let att2 = "attribute 2";

        assert_ne!(hash_to_curve(att1.as_bytes(), gen1), hash_to_curve(att2.as_bytes(), gen1));
        assert_eq!(hash_to_curve(att1.as_bytes(), gen1), hash_to_curve(att1.as_bytes(), gen1));
    }

    #[test]
    fn test_hash_to_g2() {
        let mut rng = rand::thread_rng();
        let gen1: G2 = rng.gen();
        let att1 = "attribute 1";
        let att2 = "attribute 2";

        assert_ne!(hash_to_curve(att1.as_bytes(), gen1), hash_to_curve(att2.as_bytes(), gen1));
        assert_eq!(hash_to_curve(att1.as_bytes(), gen1), hash_to_curve(att1.as_bytes(), gen1));
    }

    #[test]
    fn test_hash_to_gt() {
        let mut rng = rand::thread_rng();
        let gen1: Gt = rng.gen();
        let att1 = "attribute 1";
        let att2 = "attribute 2";

        assert_ne!(hash_to_gt(att1.as_bytes(), gen1), hash_to_gt(att2.as_bytes(), gen1));
        assert_eq!(hash_to_gt(att1.as_bytes(), gen1), hash_to_gt(att1.as_bytes(), gen1));
    }
}