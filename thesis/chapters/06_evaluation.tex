\chapter{Evaluation}

\section{Performance of \texttt{rabe\_bn}}
See Table~\ref{tbl:rabebn-performance} for performance measurements of random element sampling, group operations, group-scalar exponentiation and the pairing operation.
The times have been measured using randomly sampled elements and averaged over 100 calls each.

\begin{center}
    \begin{tabular}{|c|r|r|}\hline%
        Operation & SoC [ms] & Laptop [ms]\\\hline\hline
        \csvreader[late after line=\\]%
        {data/bn-smpl.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
        \csvreader[late after line=\\]%
        {data/bn-groupop.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
        \csvreader[late after line=\\]%
        {data/bn-groupexp.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
        \csvreader[late after line=\\]%
        {data/bn-pairing.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
    \end{tabular}  
    \captionof{table}{Execution times for various operations on the SoC and the laptop}
    \label{tbl:rabebn-performance}
\end{center}


It is apparent that the the cost of the operations differs greatly between the groups. 
Sampling a random element takes about the same time as group exponentiation for $\mathbb{G}_1$ and $\mathbb{G}_2$, but is significantly more costly for $\mathbb{G}_T$.
Looking at the implementation, the reason for this is obvious: Sampling from $\mathbb{G}_1$ and $\mathbb{G}_2$ simply generates a random $z \in \mathbb{F}_r$ and returns the group element $z \cdot G$ for $G$ a generator.
Sampling from $\mathbb{G}_T$ is done by generating random elements of $\mathbb{G}_1$ and $\mathbb{G}_2$ and computing their pairing.
This is reflected in the measured timings.

% \csvreader[tabular=|r|r|r|,
%     table head=\hline & Soc [ms] & Laptop [ms]\\\hline\hline,
%     late after line=\\\hline]
%     {data/smpl-times.csv}{description=\description,soc=\soc,laptop=\laptop}
%     {\thecsvrow & \description & \soc & \laptop}

% \begin{tabular}{|r|r|r|}\hline%
%     & SoC [ms] & Laptop [ms]\\\hline
%     \csvreader[late after line=\\]%
%         {data/smpl-times.csv}{description=\description,soc=\soc,laptop=\laptop}%
%         {\description & \soc & \laptop}%
% \end{tabular}\

Interestingly, RAM size seems to be a limiting factor when computing pairings on embedded devices.
During development, I also tested the ported \texttt{rabe-bn} library on the nRF52832 SoC, which has 64KB of RAM (vs. 256KB in the nRF52840). 
On this chip, a pairing could be computed successfully only if the library was built \emph{without debug symbols}.
With debug symbols, there was not enough RAM available and the pairing computation failed.
This suggests that the memory use during pairing computation is close to 64KB, which would still be a quarter of the RAM on the nRF52840 SoC.
While this memory is not consumed permanently, it still needs to be available when the pairing function is called.

\section{Performance of the ABE schemes}

For performance measurements of the GPSW and YCT \acrshortpl{abes}, see Figure~\ref{fig:abe-performance-diagrams}. 
The diagrams show the time required to compute Setup, Encryption, Key Generation and Decryption on the laptop and on the nRF52840 SoC.

\begin{figure}[h]\centering
    \begin{subfigure}[h]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of GPSW \cite{goyal_attribute-based_2006} on the SoC},
                xlabel={attributes / leaf nodes},
                ylabel={seconds},
                xmin=0, xmax=32,
                ymin=0, ymax=25500000,
                scaled y ticks=base 10:-6,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west,
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/gpsw06-soc.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/gpsw06-soc.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/gpsw06-soc.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/gpsw06-soc.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure}%
    \hspace{0.09\textwidth}
    \begin{subfigure}[h]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of YCT \cite{yao_lightweight_2015} on the SoC},
                xlabel={attributes / leaf nodes},
                ylabel={seconds},
                xmin=0, xmax=32,
                ymin=0, ymax=25500000,
                scaled y ticks=base 10:-6,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west,
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/yct14-soc.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/yct14-soc.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/yct14-soc.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/yct14-soc.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure}%
    % \caption{Performance of GPSW and YCT on the SoC.}
    \vspace{1cm}
    \begin{subfigure}[h]{0.448\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of GPSW \cite{goyal_attribute-based_2006} on the laptop},
                xlabel={attributes / leaf nodes},
                ylabel={milliseconds},
                xmin=0, xmax=32,
                ymin=0, ymax=110000,
                scaled y ticks=base 10:-3,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west,
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/gpsw06-laptop.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/gpsw06-laptop.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/gpsw06-laptop.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/gpsw06-laptop.csv};
            % \addplot [color=black, mark=+] table [x=atts,y=dec2,col sep=comma] {data/gpsw06-laptop.csv};
            % \addplot [color=olive, mark=+] table [x=atts,y=dec3,col sep=comma] {data/gpsw06-laptop.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure}
    \hspace{0.09\textwidth}
    \begin{subfigure}[h]{0.448\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of YCT \cite{yang_lightweight_2020} on the laptop},
                xlabel={attributes / leaf nodes},
                ylabel={milliseconds},
                xmin=0, xmax=32,
                ymin=0, ymax=110000,
                scaled y ticks=base 10:-3,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west, 
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/yct14-laptop.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/yct14-laptop.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/yct14-laptop.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/yct14-laptop.csv};
            % \addlegendentry{Decrypt};
            % \addplot [color=black, mark=+] table [x=atts,y=dec2,col sep=comma] {data/yct14-laptop.csv};
            % \addplot [color=olive, mark=+] table [x=atts,y=dec3,col sep=comma] {data/yct14-laptop.csv};
            % \addplot [color=green, mark=+] table [x=atts,y=dec4,col sep=comma] {data/yct14-laptop.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure}
    \caption{Performance of GPSW and YCT on the SoC and on the laptop. Note the different scales between the SoC and the laptop (seconds vs. milliseconds!)}
    \label{fig:abe-performance-diagrams}
\end{figure}

\subsection{Methods of measurement}
For Setup, the number of attributes refers to the total number of attributes in the system.

For Encrypt, the number of attributes refers to the number of attributes under which a ciphertext is encrypted.

For KeyGen, the number of attributes refers to the number of leaf nodes in the used access policy.
The \glspl{access-tree} used for this evaluation were generated using a python script, starting with a single node and incrementally adding leaf nodes in random positions to the tree.
To minimize the effects of specific \glspl{access-tree}, ten sets of policies with size 1 to 30 were generated.
The timings for KeyGen and Decrypt represent the average for the policies of the respective size from each of the ten sets.

For Decrypt, the same access policies from KeyGen are used to decrypt a ciphertext encrypted with all system attributes.
This ensures that the ciphertext can always be decrypted, and does not influence the decryption speed.
The decryption algorithms perform a pre-calculation of a minimal subset of the \gls{access-tree} required to satisfy the policy to reduce the number of pairings (which are necessary only at the leafs).
Therefore, the timing for decryption greatly depends on the specific structure of an \gls{access-tree} and the values given here must be understood as a rough heuristic.

Due to the small RAM size, KeyGen and Decrypt failed for policies of larger size with GPSW on the SoC.
This is why the KeyGen and Decrypt timings were omitted for policies of more than 26 attributes in the first diagram:
For \glspl{access-tree} with 27-attributes, KeyGen and Decrypt succeeded only for two of the ten tested trees.

\subsection{Results}
Two results are immediately visible from the diagrams:
First, the laptop is obviously much faster than the SoC.
This was expected and any other result would be deeply concerning.

Second, the pairing-free YCT scheme is significantly faster than the pairing-based GPSW scheme on both platforms. 
Setup and encryption for the respective schemes take about the same time.
In both setup and encryption, GPSW has a constant overhead of about four seconds, which is not present with YCT:
On the SoC, setup and encryption with a single attribute take about 4 seconds with GPSW and only about 0.4 seconds with YCT.
With 30 attributes, GPSW requires about 8.5 seconds and YCT about 5 seconds.
In other words, the additional time per attribute seems to be constant at around 150ms, which is exactly the time needed to perform an exponentiation in $\mathbb{G}_1$.
\chapter{Discussion}

\chapter{Conclusion}