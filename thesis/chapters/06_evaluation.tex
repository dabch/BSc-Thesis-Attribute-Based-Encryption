\chapter{Evaluation}

\section{Performance of \texttt{rabe\_bn}}\label{sec:rabebn-evaluation}
See Table~\ref{tbl:rabebn-performance} for performance measurements of random element sampling, group operations, group-scalar exponentiation and the pairing operation.
The times have been measured using randomly sampled elements and averaged over 100 calls each.

\begin{center}
    \begin{tabular}{|c|r|r|}\hline%
        Operation & SoC [ms] & Laptop [ms]\\\hline\hline
        \csvreader[late after line=\\]%
        {data/bn-smpl.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
        \csvreader[late after line=\\]%
        {data/bn-groupop.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
        \csvreader[late after line=\\]%
        {data/bn-groupexp.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
        \csvreader[late after line=\\]%
        {data/bn-pairing.csv}{op=\op,soc=\soc,laptop=\laptop}%
        {\op&\soc&\laptop}%
        \hline
    \end{tabular}  
    \captionof{table}{Execution times for various operations on the SoC and the laptop}
    \label{tbl:rabebn-performance}
\end{center}


It is apparent that the the cost of the operations differs greatly between the groups. 
Sampling a random element takes about the same time as group exponentiation for $\mathbb{G}_1$ and $\mathbb{G}_2$, but is significantly more costly for $\mathbb{G}_T$.
Looking at the implementation, the reason for this is obvious: Sampling from $\mathbb{G}_1$ and $\mathbb{G}_2$ simply generates a random $z \in \mathbb{F}_r$ and returns the group element $z \cdot G$ for $G$ a generator.
Sampling from $\mathbb{G}_T$ is done by generating random elements of $\mathbb{G}_1$ and $\mathbb{G}_2$ and computing their pairing.
This is reflected in the measured timings.

% \csvreader[tabular=|r|r|r|,
%     table head=\hline & Soc [ms] & Laptop [ms]\\\hline\hline,
%     late after line=\\\hline]
%     {data/smpl-times.csv}{description=\description,soc=\soc,laptop=\laptop}
%     {\thecsvrow & \description & \soc & \laptop}

% \begin{tabular}{|r|r|r|}\hline%
%     & SoC [ms] & Laptop [ms]\\\hline
%     \csvreader[late after line=\\]%
%         {data/smpl-times.csv}{description=\description,soc=\soc,laptop=\laptop}%
%         {\description & \soc & \laptop}%
% \end{tabular}\

Interestingly, RAM size seems to be a limiting factor when computing pairings on embedded devices.
During development, I also tested the ported \texttt{rabe-bn} library on the nRF52832 SoC, which has 64KB of RAM (vs. 256KB in the nRF52840). 
On this chip, a pairing could be computed successfully only if the library was built \emph{without debug symbols}.
With debug symbols, there was not enough RAM available and the pairing computation failed.
This suggests that the memory use during pairing computation is close to 64KB, which would still be a quarter of the RAM on the nRF52840 SoC.
While this memory is not consumed permanently, it still needs to be available when the pairing function is called.

\section{Performance of the ABE schemes}

For performance measurements of the GPSW and YCT \acrshortpl{abes}, see Figure~\ref{fig:abe-performance-diagrams}. 
The diagrams show the time required to compute Setup, Encryption, Key Generation and Decryption on the nRF52840 SoC and the laptop.
The timings for the laptop are purely there to give some context; the evaluation focuses on the performance on the SoC.

\begin{figure}[h]\centering
    \begin{subfigure}[h]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of GPSW \cite{goyal_attribute-based_2006} on the SoC},
                xlabel={attributes / leaf nodes},
                ylabel={seconds},
                xmin=0, xmax=32,
                ymin=0, ymax=25500000,
                scaled y ticks=base 10:-6,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west,
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/gpsw06-soc.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/gpsw06-soc.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/gpsw06-soc.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/gpsw06-soc.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure}%
    \hspace{0.09\textwidth}
    \begin{subfigure}[h]{0.45\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of YCT \cite{yao_lightweight_2015} on the SoC},
                xlabel={attributes / leaf nodes},
                ylabel={seconds},
                xmin=0, xmax=32,
                ymin=0, ymax=25500000,
                scaled y ticks=base 10:-6,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west,
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/yct14-soc.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/yct14-soc.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/yct14-soc.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/yct14-soc.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure}%
    % \caption{Performance of GPSW and YCT on the SoC.}
    \vspace{1cm}
    \begin{subfigure}[h]{0.448\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of GPSW \cite{goyal_attribute-based_2006} on the laptop},
                xlabel={attributes / leaf nodes},
                ylabel={milliseconds},
                xmin=0, xmax=32,
                ymin=0, ymax=110000,
                scaled y ticks=base 10:-3,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west,
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/gpsw06-laptop.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/gpsw06-laptop.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/gpsw06-laptop.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/gpsw06-laptop.csv};
            % \addplot [color=black, mark=+] table [x=atts,y=dec2,col sep=comma] {data/gpsw06-laptop.csv};
            % \addplot [color=olive, mark=+] table [x=atts,y=dec3,col sep=comma] {data/gpsw06-laptop.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure}
    \hspace{0.09\textwidth}
    \begin{subfigure}[h]{0.448\textwidth}
        \begin{tikzpicture}
            \begin{axis}[
                title={Timing of YCT \cite{yang_lightweight_2020} on the laptop},
                xlabel={attributes / leaf nodes},
                ylabel={milliseconds},
                xmin=0, xmax=32,
                ymin=0, ymax=110000,
                scaled y ticks=base 10:-3,
                ytick scale label code/.code={}, % removes the '\cdot 10^3' label 
                legend pos=north west, 
                grid=major,
                grid style=dashed,
                legend style={nodes={scale=0.65, transform shape}}
            ]
            \addlegendentry{Setup};
            \addplot [color=orange, mark=square] table [x=atts,y=setup,col sep=comma] {data/yct14-laptop.csv};
            \addlegendentry{Encrypt};
            \addplot [color=blue, mark=triangle] table [x=atts,y=enc,col sep=comma] {data/yct14-laptop.csv};
            \addlegendentry{KeyGen};
            \addplot [color=green, mark=o] table [x=atts,y=keygen,col sep=comma] {data/yct14-laptop.csv};
            \addlegendentry{Decrypt};
            \addplot [color=red, mark=+] table [x=atts,y=dec,col sep=comma] {data/yct14-laptop.csv};
            % \addlegendentry{Decrypt};
            % \addplot [color=black, mark=+] table [x=atts,y=dec2,col sep=comma] {data/yct14-laptop.csv};
            % \addplot [color=olive, mark=+] table [x=atts,y=dec3,col sep=comma] {data/yct14-laptop.csv};
            % \addplot [color=green, mark=+] table [x=atts,y=dec4,col sep=comma] {data/yct14-laptop.csv};
            \end{axis}
        \end{tikzpicture}
    \end{subfigure} 
    \caption[Performance of ABE schemes on the SoC and laptop]{Performance of GPSW and YCT on the SoC and on the laptop. Note the different scales between the SoC and the laptop (seconds vs. milliseconds!)}
    \label{fig:abe-performance-diagrams}
\end{figure}

\subsection{Methods of measurement}

All times were measured using a hardware timer (on the SoC) and the operating system time (on the laptop) with microsecond resolution.

For Setup, the number of attributes refers to the total number of attributes in the system.
For Encrypt, the number of attributes refers to the number of attributes under which a ciphertext is encrypted.

For KeyGen, the number of attributes refers to the number of leaf nodes in the used access policy.
The \glspl{access-tree} used for this evaluation were generated using a python script, starting with a single node and incrementally adding leaf nodes in random positions to the tree.
To minimize the effects of specific \glspl{access-tree}, ten sets of policies with size 1 to 30 were generated.
The timings for KeyGen and Decrypt represent the average for the policies of the respective size from each of the ten sets.

For Decrypt, the same access policies from KeyGen are used to decrypt a ciphertext encrypted with all system attributes.
This ensures that the ciphertext can always be decrypted, and does not influence the decryption speed.
The decryption algorithms perform a pre-calculation of a minimal subset of the \gls{access-tree} required to satisfy the policy to reduce the number of pairings (which are necessary only at the leafs).
Therefore, the timing for decryption greatly depends on the specific structure of an \gls{access-tree} and the values given here must be understood as a rough heuristic.

Due to the small RAM size, KeyGen and Decrypt failed for policies of larger size with GPSW on the SoC.
This is why the KeyGen and Decrypt timings were omitted for policies of more than 25 attributes in the first diagram:
For \glspl{access-tree} with 26 attributes, KeyGen and Decrypt succeeded only for two of the ten tested trees.

\subsection{Results}
Two results are immediately visible from the diagrams:
First, the laptop is obviously much faster than the SoC.
This was expected and any other result would be very surprising.

Second, the pairing-free YCT scheme is significantly faster than the pairing-based GPSW scheme on both platforms. 
For both schemes, Setup takes about the same time as Encryption for the same number of attributes in the system or ciphertext, respectively.
In both Setup and Encryption, the difference between GPSW and YCT for the same number of attributes is constant:
On the SoC, setup and encryption with a single attribute take about 4 seconds with GPSW and only about 0.4 seconds with YCT.
With 30 attributes, GPSW requires about 8.5 seconds and YCT about 5 seconds.
The runtimes increase linearly in both, with each additional attribute adding about 150ms.

For the KeyGen algorithm, difference is even larger:
The runtime of GPSW increases considerably for a larger number of attributes.
With one attribute, KeyGen takes about 650ms. With 25 attributes, it already takes more than 16 seconds.
The runtime of YCT only increases slightly from 35ms for one attribute to 210ms for 25 attributes.
For more than 25 attributes, GPSW-KeyGen could not meaningfully be evaluated on the SoC due to lack of RAM.
Only for two of the ten sets, KeyGen ran successfully for all policy sizes up to 30.
In one of the ten randomly generated sets, KeyGen already failed with only nine attributes.
This shows how strongly the required time and resources depend on the concrete structure of a policy.

For decryption, this influence is even stronger because of the further optimization to evaluate only a minimal subset of the \gls{access-tree} (this optimization is not applicable for KeyGen).
But again, YCT is much, much faster than GPSW: For larger policies, decryption takes about eight to ten times longer for GPSW than it takes for YCT.

The relative timings between the algorithms differs between the two schemes:
For GPSW, Decrypt is by far the slowest, except for very small number of attributes. KeyGen is only slightly slower.
Encrypt and Setup are the fastest algorithms of GPSW.

For YCT, Encrypt and Setup are the slowest.
Decrypt comes second and KeyGen is by far the fastest.
But still, the slowest algorithms of YCT are much faster than the fastest of GPSW.


\section{Discussion}
The results for Setup and Encrypt are in line with the time-consuming operations performed by the algorithms: 
In both schemes, each additional attribute results in one additional exponentiation in $\mathbb{G}_1$.
This takes about 150ms as per Table~\ref{tbl:rabebn-performance}, which is exactly the additional time per attribute.
The constant overhead of about 3.5 with GPSW is a result of the pairing computation and exponentiation in $\mathbb{G}_T$ (for Setup) and the sampling and exponentiation in $\mathbb{G}_T$ (for Encrypt).

For the KeyGen algorithm, the speed difference between YCT and GSPW is especially striking: 
The YCT algorithm is extremely fast for a small number of attributes (below 100ms) and only increases slightly as more attributes are added.
GPSW is not only slower already for a few attributes, but its runtime also increases much more quickly when increasing the policy size.
Again, looking at the schemes, the reason becomes evident: YCT's KeyGen only works on elements of $\mathbb{F}_r$, which are small and easy to calculate with.
GPSW uses secret shares from $\mathbb{G}_2$, for which operations take considerably more time.
This is also the case for decryption: YCT only requires exponentation and point addition in $\mathbb{G}_1$, whereas GPSW performs pairings, multiplications and exponentiations in $\mathbb{G}_T$.

If some latency is acceptable, doing \acrshort{abe} on the SoC definitely seems feasible for small policy sizes (up to 30 for YCT and up to about 15 for GPSW).
From a performance point of view, the pairing-free YCT scheme is to be preferred, as it was faster in all respects.
It also doesn't suffer from the RAM size issues with key generation and decryption as GPSW does.
This clearly results from the lack of pairing computations, which already take up about one quarter of the total RAM on the SoC (c.f. Section~\ref{sec:rabebn-evaluation}).

However, as the security of pairing-free \acrshort{abes} is questioned (\cite{herranz_attacking_2020}), a pairing-based scheme might be preferable.
Even though decryption with GPSW is limited to small policies by the RAM size issues and long run times, it is feasible for small policies (max. 5-10 attributes).
For encryption, even larger number of attributes are viable: The additional time per attributes is the same as with YCT and even for 30 attributes there were no RAM size issues.
Thus, the relative advantage of YCT over GPSW becomes smaller with larger policies.
Even for 
% TODO section on why only encryption is really relevant and that especially keygen and setup should only run on a proper computer
% TODO write about splitting up encryption like for medisec, and why then up to 10seconds encryption time are okay (?)


\section{Further Improvements / Future Work}

For embedded applications, computation time is not the only important factor. 
The large size of \acrshort{abe} ciphertexts can be a problem, e.g. when transmitting data via low-power wireless protocols (such as Bluetooth LE).
In addition to the hybrid encryption approach taken in this thesis (key encapsulation, i.e. choosing a random symmetric key to encrypt the payload and then encrypting this key using \acrshort{abe}), measures such as point compression can be taken.

Another option to reduce both message sizes and encryption times would be to re-use the ABE-encapsulated symmetric key: 
Instead of encrypting each message with a new random symmetric key that is encapsulated with \acrshort{abe}, the same symmetric key can be used for many messages. 
For example, an embedded sensor could choose a new symmetric key once per day, encrypt it using ABE and transmit it to the cloud. 
Then it could use this key to encrypt all messages for the next 24 hours, requiring very short encryption times and little overhead for the message size. 
This construction was already implemented for the \emph{Medisec} application, but not evaluated for this thesis because it is not a ``true'' \acrlong{abes}.
% TODO check that this section is in line with the introduction / medisec overview



\chapter{Conclusion}

ABE is feasible, but only for encryption, only when a few seconds wait time is ok and for small policy sizes / attribute numbers.