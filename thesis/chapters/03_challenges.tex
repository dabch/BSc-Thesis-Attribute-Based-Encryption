\chapter{Challenges encountered during the implementation}\label{chapter:challenges}

\section{Rust specialties}
The borrow checkaaa...

\section{Lack of Operating System}
This means lack of

\begin{itemize}
    \item allocator and standard library (replaced by \texttt{core}, but much less powerful)
    \begin{itemize}
        \item any dynamically allocated data structures
        \item No Vectors and HashMaps Vectors and HashMaps
        \item no easy implementation of (access-) trees using recursive enums (as these would become infinitely large when not using indirections)
        \item most dependencies depend on \texttt{std} in some way, so a lot more work to make all those independent
        \item Solution: \texttt{heapless} crate and linear representation of access trees (TODO make bounds on size of data types configurable)
    \end{itemize}
    \item Random Number Generation
    \begin{itemize}
        \item Problem: need cryptographically secure randomness, but have no OS randomness pool
        \item can't just use \texttt{/dev/urandom} to get randomness (there is no such thing as a file anyway)
        \item standard implementations of \texttt{random} resp. \texttt{getrandom} crates don't work (rely on stdlib)
        \item need own randomness source
        \item nrf50 series provides hardware RNG, but we need Rust to be able to interface with this
        \item probably need own implementation of \texttt{getrandom} crate for Zephyr OS or bare-metal nrf50
    \end{itemize}
    \item Unit testing abilities
\end{itemize}

\section{Performance Limitations}
That is, CPU speed (64MHz) and RAM size (..KiB?). 
\begin{itemize}
    \item probably too slow for computing actual pairings
    \item Solution 1: Scheme without pairings (Yao et al 2015) 
    \item Solution 2: Still do pairings, but hyper-optimize (see TinyPBC on AVR)
\end{itemize}