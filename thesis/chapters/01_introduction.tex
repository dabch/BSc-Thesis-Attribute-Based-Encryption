% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Introduction}\label{chapter:introduction}

\acrfull{abe} promises to provide security while improving flexibility over standard cryptosystems.
Its approach of combining \glspl{attribute} and \glslink{access-policy}{policies} describing admissible attribute combinations is closer to traditional notions of access control (e.g. RBAC) than conventional encryption~\cite{bethencourt_ciphertext-policy_2007}.

This increased flexibility is also desirable for \acrshort{iot} applications.
However, the \acrfull{iot} is especially affected by the trade-off between cost and security:
Because hardware must be cheap and has to run on batteries, it is often highly constrained.
Many traditional security measures, even some standard cryptographic algorithms, are not practical on \acrshort{iot} devices.
Compared to standard cryptography, most \acrshortpl{abes} demand even more resources~\cite{wang_performance_2014}.
Thus, the feasibility of \acrshort{abe} on constrained \acrshort{iot} nodes is disputed~\cite{ambrosin_feasibility_2016,ambrosin_feasibility_2015,borgh_attribute-based_2016,girgenti_feasibility_2019,wang_performance_2014}.

The objective of this thesis is to assess to what extent \acrshort{abe} can be practically applied on ARM Cortex M4 processors.
To this end, an \acrshort{abe} library is developed using the Rust programming language.
This library is then tested and evaluated on the nRF52840 SoC with a 64\,MHz ARM Cortex M4 processor and 256\,KB of RAM.
In addition, this thesis aims to give an easy-to-understand explanation of \acrshort{abe} and how it can be implemented.

\input{figures/01_system_architecture}

For a real-world use-case of this library in the medical field, see Figure~\ref{fig:system-architecture}.
It is assumed that the sensor (e.g. an ECG or blood glucose sensor) is unable to communicate with the internet directly.
Therefore, the data is sent to a gateway by \acrfull{ble} and then uploaded to the cloud.

The goal of this project is to enable end-to-end \acrlong{abe}:
Measurements are encrypted on the sensor before they are transmitted over \acrshort{ble} and only decrypted when read by an authorized client (e.g. the attending doctor).
In this system, the sensor exclusively needs to encrypt data; decryption, key generation and setup are not required on the constrained node, which is the case in many \acrshort{iot} applications.

The end-to-end \acrshort{abe} approach does not require trust in the gateway or cloud provider.
Trusting them would be an unreasonable assumption in many scenarios.

An alternative to encryption with \acrshort{abe} on the sensor would be outsourcing the \acrshort{abe} operations to the gateway:
The sensor and gateway share a secret key, which is used to secure the communication over \acrshort{ble}.
The gateway then decrypts the symmetrically encrypted data and re-encrypts it using \acrshort{abe}.
This approach does not require \acrshort{abe} on the sensor, only on the gateway.
The latter is assumed to be much more powerful than the sensor.
However, the gateway must be trusted in this scenario.

An alternative using only \glslink{privkes}{symmetric cryptography} would be to let the cloud server enforce access control:
All participants exchange a secret key with the cloud server.
The sensor then uses this key to encrypt the data, which only the cloud server can read.
When a user wants to access some data, they request it at the cloud server.
If the cloud server grants their request, the server re-encrypts the data with the respective user's key and transmits it to them.
This approach removes trust in the gateway and requires only \glslink{privkes}{symmetric encryption} for all participants, which is much faster than \acrshort{abe}.
The disadvantage is that the cloud server knows all data in plain text. It thus needs to be trusted and represents a single point of failure.

End-to-end \acrshort{abe} removes trust in the gateway and the cloud server, but it does not remove the single point of failure:
A malicious \acrfull{kgc} could issue keys that allow decryption of arbitrary data (see Section~\ref{sec:kgc}).
However, the \acrshort{kgc} is only required to setup the \acrshort{abe} system and issue the participant's keys.
It is not involved in any encryption or decryption operations.
The \acrshort{kgc} does not need to be online during the use of the system and could e.g. be located on an air-gapped network and only be connected when new a users joins the system. 
This greatly reduces the attack surface.
% ~\\

% \emph{Martin: }
% hier wünsche ich mir vor allem die Motivation und eine Einordnung ins große Ganze. Du kannst gern den Medisec Anwendungsfall als Beispiel hernehmen, an dem du das diskutierst, musst du aber nicht

% - Warum sollte ich ABE hernehmen?\\ 
% - Welche Probleme löst es, die ich sonst nicht elegant lösen kann? (Update nach dem Lesen von 2.1: da erklärst du es super. Dann hier halt in kurz "gut für Verschlüsselung an mehrere Empfänger") \\
% - Welche Alternativen zu ABE gäbe es denn überhaupt? Was ist nervig an ABE (z.B. dass man ein KGC braucht?)\\
% - Ist das sinnvoll, das auf Mikrocontrollern zu machen? \\

% In der BA ist es noch nicht so wichtig wie in der MA, dass du eine zentrale Forschungsfrage hinschreibst. Wenn du es aber kannst, macht es den Rest leichter weil du die ganze Arbeit dran strukturieren kannst. Vor allem beim Related Work zusammenstellen hilft es, siehe meine Anmerkungen da. 
% Nach meinem Verständnis behandelst du die Frage "kann man ABE gescheit auf Mikrocontrollern machen?". Ggf. kann man den Titel der BA noch dahingehend anpassen, dass er mehr sciency klingt ("Implementierung" ist "Ingenieurs-Handwerk" und das findet der Academia Mensch unter seiner Würde. Ist Quatsch, aber leider ticken die so). Also wenn du mehr sciency klingen willst etwa "Evaluating the feasibility of a Rust-based ABE Library on MCUs" --> Evaluation ist wieder die ureigenste Aufgabe des Scientisten, also alles gut.
