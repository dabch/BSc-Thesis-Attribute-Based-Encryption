\chapter{Implementation}

This chapter describes how the schemes from Chapter~\ref{chapter:constructions} were implemented on a lower level.
It shall make clear what challenges had to be overcome to run \acrshort{abe} on the sensor.

\section{Hardware}

The main goal of this project was to implement an \acrshort{abe} scheme on a constrained embedded ARM processor.
More specifically, the chip used was a Nordic Semiconductor nRF52840 with a 64\,MHz Cortex M4 CPU, 256\,KB of RAM and 1\,MB of flash storage.
For the detailed specifications, see \cite{noauthor_nrf52840_nodate}.
This SoC will be referred to simply as `the SoC'.

For reference, the implementation was also tested on a standard laptop, referred to as `the Laptop'.
More specifically, this system has a 2.7\,GHz Intel i7-7500U CPU and 16\,GB of RAM.
It runs a Linux-based operating system.

\section{Programming language and libraries}

\subsection*{Rust}

Rust was chosen as programming language for this project.
First, it is a compiled language and thus incurs little overhead at runtime. Its speed is comparable to that of C/C++.
Second, it provides much stronger memory safety guarantees than other compiled languages (especially C/C++ where extreme care is required to avoid introducing exploitable vulnerabilities).
This is especially attractive for security-critical components like an encryption library.

\subsection*{The \texttt{rabe-bn} library}

A Rust-only implementation of elliptic curves and a pairing is provided by the open-source library \texttt{rabe-bn}~\cite{bowe_bn_2016}, a derivative of the \texttt{bn} library by Zcash~\cite{bowe_bn_2016}.
It implements a concrete pairing on 256-bit \emph{BN curves}.
BN curves are a family of pairing-friendly elliptic curves proposed by Barreto and Naehrig \cite{barreto_pairing-friendly_2006}.

The 256-bit modulus of the BN curve used in \texttt{rabe-bn} was originally believed to provide a security level of 128 bits~\cite{ben-sasson_succinct_2013}. 
Due to the discovery of better attacks on the underlying cryptographic assumptions, the estimate for the security level has been revised down to 100 bits~\cite{yonezawa_pairing-friendly_2019}.

The library provides four structs: \texttt{G1}, \texttt{G2} and \texttt{Gt}, elements of the groups $\mathbb{G}_1$, $\mathbb{G}_2$ and $\mathbb{G}_T$, respectively.
Let their orders be $r$, then \texttt{Fr} represents an element of the field $\mathbb{F}_r$.

For the elliptic curve groups (structs \texttt{G1} and \texttt{G2}), additive notation is used and the \texttt{*} operator is conveniently overloaded.
The target group (struct \texttt{Gt}) uses multiplicative notation.
For this reason, the description of the schemes in Chapter~\ref{chapter:constructions} has also been adapted to use compatible notation.

\subsection*{nRF52840 HAL crate}
For easier access to the peripherals of the SoC, the \acrfull{hal} \gls{crate} \texttt{nrf52840-hal} was also used.
It provides simplified access to the hardware \acrfull{rng} and the timers.
Strictly speaking, these were not necessary to build a Rust library (timers are only needed for evaluation and the library interface allows the caller to pass their desired random number generator).
However, for testing and actual use of the library bare-metal on the SoC, both the \acrshort{rng} and the timers were needed. % TODO maybe remove last two sentences

\subsection*{\texttt{heapless} crate}
The \texttt{heapless}~\cite{aparicio_heapless_nodate} crate provides stack-allocated versions of some of the data structures from \texttt{std::collections}. 
Most important were \texttt{heapless::Vec} (replaces \texttt{std::vec::Vec}) and \texttt{heapless::IndexMap} (replaces \texttt{std::collections::HashMap}).
These data structures are statically allocated and expect their desired capacity as an additional generic type parameter.

\section{Porting \texttt{rabe-bn} to the SoC}

% TODO link the modified library github somewhere
The implementation of \texttt{rabe-bn} unfortunately relied on the standard library (mostly through the use of heap-allocated dynamic vectors, i.e. \texttt{std::vec::Vec}) and is thus not suited for bare-metal applications.
Rust provides the dependency-free and platform-agnostic \texttt{core} library as an alternative to the standard library.
This library does not depend on an operating system or dynamic memory allocation, and thus does not include heap-allocated data structures (like \texttt{std::vec::Vec}).

Therefore, I rewrote the \texttt{rabe-bn} library to introduce a cargo-feature \texttt{std} which controls the inclusion of the standard library and is enabled by default.
If this feature is disabled, the \texttt{core} library and stack-allocated collections of fixed size from the \texttt{heapless} crate are used instead.

Some further modifications were necessary to implement the \texttt{core::fmt::Display} trait for the \texttt{Gt} struct in a bare-metal compatible manner.
The implementation of this trait was used in conjunction with \acrshort{sha3} as a \gls{kdf} to create an AES key from curve points.
The behavior of the \texttt{core::fmt::Display} implementation stayed exactly the same to ensure interoperability with the original \texttt{rabe-bn} library.
% TODO Stefans Feedback einarbeiten: Besser beschreiben wie Key abgeleitet wird!

With these modifications, the \texttt{rabe-bn} library runs on the SoC.

\section{Random Number Generation}
Regular Rust programs use the \texttt{rand} \gls{crate}'s \verb+ThreadRng+ struct to generate random numbers.
\texttt{ThreadRng} is cryptographically secure~\cite{noauthor_rust_nodate}, but it relies on the operating system randomness pool for seeding.

Therefore, this generator is unavailable on the SoC.
Instead we use the hardware \acrshort{rng}.
The \texttt{nrf52840-hal} crate directly implements the trait \texttt{rand::RngCore} for the hardware \acrshort{rng}, which makes it relatively easy to use.
This generator, however, is quite slow and speed can differ greatly: With bias correction enabled (required for uniform distribution of the generated data), typically around 120$\mu$s per byte~\cite{noauthor_nrf52840_nodate}.

To alleviate this, the hardware \acrshort{rng} is only used to seed a ChaCha20 pseudorandom number generator (crate \texttt{rand\_chacha}).
This is essentially the same construction as the current implementation of \texttt{ThreadRng}~\cite{noauthor_rust_nodate}.

\section{Aspects common to both ABE schemes}

\subsection{Representation of Access Trees}
The Rust type system is very well suited to represent the type of tree structures we need for Access Trees.
A simple implementation might look like the one in Listing~\ref{lst:access-tree-naive}. 

\begin{lstlisting}[caption={Simple Implementation of Access Trees (using the standard library)},label={lst:access-tree-naive}]
enum AccessTree<'a> {
    // threshold, vector of children
    Node(u64, std::vec::Vec<AccessTree<'a>>),
    // reference to the attribute label
    Leaf(&'a str),
}
\end{lstlisting}

This, however, does not work when the \texttt{std::vec::Vec} is replaced by a stack-allocated \texttt{heapless::Vec}:
The \texttt{std::vec::Vec} is allocated on the heap and thus only a pointer to the vector needs to be stored in the \texttt{AccessTreeNode}.
This pointer has constant size, of course.

A \texttt{heapless::Vec} is not located on the heap, but directly inside the \texttt{AccessTreeNode}.
Even if there is a limit on the number of children a single inner node might have, there is no limit to the depth of the access tree.
Therefore, an \texttt{AccessTreeNode} might be arbitrarily large because the \texttt{heapless::Vec} might need to hold an arbitrary number of child nodes.

Because of this, Access Trees were implemented as a flat slice of nodes as in Listing~\ref{lst:access-tree-heapless}. 
The vector of children doesn't hold references to the children themselves, but only their index within the vector of Access Tree nodes.
This again introduces an indirection (like the heap pointer in the simple implementation) and allows the enums to have constant size.

\begin{lstlisting}[caption={Refined implementation of Access Trees (works without standard library)},label={lst:access-tree-heapless}]
type AccessTree<'a, 'b> = &'b [AccessNode<'a>];
enum AccessNode<'a> {
    // threshold, vector of child indexes
    Node(u64, heapless::Vec<u8, consts::U16>),
    // reference to the attribute label
    Leaf(&'a str),
}
\end{lstlisting}

Listing~\ref{lst:access-tree-example} shows the \gls{access-tree} from Figure~\ref{fig:sample-access-tree} in this representation.

\begin{lstlisting}[caption={Sample access tree in the heapless Rust representation},label={lst:access-tree-example}]
let access_tree: AccessTree = &[
    AccessNode::Node(2, Vec::from_slice(&[1, 2, 3]).unwrap()),
    AccessNode::Leaf("A"),
    AccessNode::Leaf("B"),
    AccessNode::Node(1, Vec::from_slice(&[4, 5]).unwrap()),
    AccessNode::Leaf("C"),
    AccessNode::Leaf("D"),
];
\end{lstlisting}

\subsection{Hybrid Encryption}
Both schemes encrypt a given plaintext using a hybrid approach:
Instead of encrypting the data with \acrshort{abe} directly, the plaintext is encrypted with AES and the key for AES is encrypted under \acrshort{abe}.
This results in faster encryption and decryption for longer ciphertexts because AES is significantly faster than ABE.

In our implementation, the \acrshort{abe} scheme generates a secret curve point (i.e. either \verb+rabe_bn::G1+ or \verb+rabe_bn::Gt+).
From this, an AES key is derived and then used to encrypt the plaintext with AES-CCM.

\subsubsection{Key derivation}
Both schemes output a randomly generated curve point to use as symmetric key.
The binary representation of these curve points is much longer than the 256-bit key AES expects.
Therefore, the curve point is run through a \gls{kdf}, which can be seen in Listing\ref{lst:kdf} in the string representation of the curve point is hashed using \acrshort{sha3}:

\begin{lstlisting}[caption={Hash-based key derivation Function for curve points},label={lst:kdf}]
struct Wrapper<W: sha3::Digest>(pub W); // newtype for sha3::Digest
impl<W: sha3::Digest> core::fmt::Write for Wrapper<W> {
    fn write_str(&mut self, arg: &str) -> fmt::Result {
        self.0.update(arg);
        Ok(())
    }
}

fn kdf<G: core::fmt::Display>(inp: &G) -> GenericArray<u8, consts::U32> {
    let mut hasher = Wrapper(Sha3_256::new());
    write!(&mut hasher, "{}", inp).unwrap();
    hasher.0.finalize()
}
\end{lstlisting}

The \verb+kdf()+ function takes any struct that implements the \texttt{core::fmt::Display} trait and outputs a 256-bit byte array (exactly the size needed for an AES key).
\texttt{Display} is a formatting trait for user-facing output, i.e. it would be used to format a struct when it is printed to the console.
Normally, \texttt{Display} is used to turn a struct into a \verb+String+, but those are implemented in the standard library and thus are not available on the SoC.
Therefore, the naive approach of using \texttt{Display} to turn our curve point into a \texttt{String} and then hashing the \texttt{String} does not work.

To circumvent this problem, I implemented the \verb+core::fmt::Write+ trait for the \acrshort{sha3} hasher using a newtype pattern.
This trait represents a sink for formatted text, like that produced by structs implementing the \verb+core::fmt::Display+ trait.
Then it is possible to simply use the \verb+write!()+ macro to write the formatted curve points (or any other struct) into the \acrshort{sha3} hasher.

\subsubsection{Symmetric Encryption}

The 256-bit key obtained from \texttt{kdf()} is then used as the key to encrypt the actual plaintext.
This is done by AES-256 in CCM mode (Counter Mode Encryption with CBC-MAC).
CCM is an AEAD mode, i.e. it secures both confidentiality and integrity of the data.

\begin{lstlisting}[caption={Symmetric Ciphertext struct},label={lst:symm-ciphertext}]
pub struct Ciphertext<'data> {
    data: &'data mut [u8],
    nonce: [u8; 13],
    mac: ccm::aead::Tag<ccm::consts::U10>,
}
\end{lstlisting}

Listing~\ref{lst:symm-ciphertext} shows the result of encryption with AES-CCM.
Because dynamic allocation of additional memory is not possible, the plaintext is encrypted in-place.
In addition to a reference to the encrypted data itself, the ciphertext stores the nonce used for the counter and the authentication tag.

The \texttt{Ciphertext} struct allows a CCM-encrypted ciphertext to be reconstructed and checked for unauthorized modifications if the key is known.
In combination with the \acrshort{abe} ciphertext, it forms a hybrid ciphertext.
This combined ciphertext can then be decrypted with a valid \acrshort{abe} key.




% fn encrypt_with_aes_key<'a>(
%     aes_key: &GenericArray<u8, consts::U32>,
%     plaintext: &'a mut [u8],
%     rng: &mut dyn RngCore) 
% -> Result<Ciphertext<'a>, AeadError> {
%     let nonce: [u8; 13] = rng.gen();

%     let ccm = Ccm::new(&aes_key);
%     let mac = ccm.encrypt_in_place_detached(
%         &GenericArray::from(nonce),
%         &[],        // associated data - empty
%         plaintext
%     )?;
%     Ok(
%         Ciphertext {
%             data: plaintext,
%             nonce,
%             mac,
%         }   
%     )
% }
% \end{lstlisting}